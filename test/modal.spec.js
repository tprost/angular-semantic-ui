// Generated by CoffeeScript 1.10.0
(function() {
  "use strict";
  describe("ui.modal", function() {
    beforeEach(function() {
      var testApp;
      testApp = angular.module("test", ["ui.modal", "ngAnimateMock"]).controller("TestCtrl", function($scope, data) {
        this.ctrlAsData = data;
        return $scope.ctrlData = data;
      });
      return angular.mock.module("test");
    });
    return describe("modalService", function() {
      beforeEach(inject(function(modalService, $document, $rootScope, $templateCache, $q, $animate) {
        this.modalService = arguments[0], this.$document = arguments[1], this.$rootScope = arguments[2], this.$templateCache = arguments[3], this.$q = arguments[4], this.$animate = arguments[5];
        return spyOn(this.$templateCache, "get").and.callFake(function(filename) {
          return {
            "modal_template.html": "<div class='scope-data' ng-bind='data'></div> <div class='ctrl-data' ng-bind='ctrlData'></div> <div class='ctrl-as-data' ng-bind='testCtrl.ctrlAsData'></div>"
          }[filename];
        });
      }));
      describe("openModal", function() {
        describe("with no options", function() {
          return it("throws an error", function() {
            return expect((function(_this) {
              return function() {
                return _this.modalService.openModal();
              };
            })(this)).toThrowError(Error, /template/);
          });
        });
        describe("with a templateUrl", function() {
          beforeEach(function() {
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html"
            });
          });
          it("returns an object that exposes useful things", function() {
            expect(this.modal).toBeDefined();
            expect(this.modal.resolved).toBeDefined();
            expect(this.modal.opened).toBeDefined();
            expect(this.modal.closed).toBeDefined();
            expect(this.modal.scope).not.toBeDefined();
            expect(this.modal.element).not.toBeDefined();
            this.$animate.flush();
            expect(this.modal.scope).toBeDefined();
            expect(this.modal.container).toBeDefined();
            return expect(this.modal.element).toBeDefined();
          });
          it("loads the template", function() {
            this.$animate.flush();
            return expect(this.$templateCache.get).toHaveBeenCalledWith("modal_template.html");
          });
          it("appends the element to the body", function() {
            this.$animate.flush();
            return expect(this.modal.element).toBeInDOM();
          });
          it("adds dimmable class to body when opened", function() {
            this.$animate.flush();
            return expect(angular.element("body").hasClass("dimmable dimmed")).toBe(true);
          });
          it("resolves the modal's opened promise", function() {
            var opened;
            opened = false;
            this.modal.opened.then(function() {
              return opened = true;
            });
            this.$animate.flush();
            return expect(opened).toBe(true);
          });
          it("resolves the modal's closed promise with the close value", function() {
            this.$animate.flush();
            this.modal.closed.then((function(_this) {
              return function(result) {
                return _this.closed_value = result;
              };
            })(this));
            this.modal.close("hello");
            this.$animate.flush();
            return expect(this.closed_value).toBe("hello");
          });
          return describe("adds event handlers that", function() {
            beforeEach(function() {
              this.$animate.flush();
              this.closed = false;
              return this.modal.closed.then((function(_this) {
                return function(result) {
                  return _this.closed = true;
                };
              })(this));
            });
            it("close modal when clicked on the container", function() {
              this.modal.container.trigger("click");
              expect(this.modal.closing).toBe(true);
              this.$animate.flush();
              return expect(this.closed).toBe(true);
            });
            it("doesn't close modal when clicked on the modal body", function() {
              this.modal.element.trigger("click");
              expect(this.modal.closing).not.toBe(true);
              this.$rootScope.$digest();
              return expect(this.closed).toBe(false);
            });
            return it("close modal when ESC is pressed", function() {
              var evt;
              evt = jQuery.Event("keydown");
              evt.which = 27;
              this.$document.trigger(evt);
              expect(this.modal.closing).toBe(true);
              this.$animate.flush();
              return expect(this.closed).toBe(true);
            });
          });
        });
        describe("when the body is empty", function() {
          return it("appends the element to the body", function() {
            angular.element("body").empty();
            this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html"
            });
            this.$animate.flush();
            return expect(this.modal.element).toBeInDOM();
          });
        });
        describe("with a template", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              template: "<div class='my-class'>This is my template</div>"
            });
          });
          return it("loads the template", function() {
            this.$rootScope.$digest();
            return expect(this.modal.element.find(".my-class").text()).toEqual("This is my template");
          });
        });
        describe("with a template and templateUrl", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              template: "<div class='my-class'>This is my template</div>",
              templateUrl: "modal_template.html"
            });
          });
          return it("loads the template, not the templateUrl", function() {
            this.$rootScope.$digest();
            expect(this.modal.element.find(".my-class").text()).toEqual("This is my template");
            return expect(this.modal.element.find(".scope-data").length).toEqual(0);
          });
        });
        describe("with a containerTemplate", function() {
          beforeEach(function() {
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              containerTemplate: "<div class='popeye-modal-container'><div class='my-header'></div><div class='popeye-modal'></div></div>"
            });
          });
          return xit("uses the provided container template", function() {
            this.$rootScope.$digest();
            return expect(this.modal.container.find(".my-header").length).toEqual(1);
          });
        });
        describe("with a containerTemplateUrl", function() {
          beforeEach(function() {
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              containerTemplate: null,
              containerTemplateUrl: "my_modal_container.html"
            });
          });
          return xit("requests the container template", inject(function($httpBackend) {
            $httpBackend.expectGET("my_modal_container.html").respond("<div class='popeye-modal-container'><div class='my-header'></div><div class='popeye-modal'></div></div>");
            this.$rootScope.$digest();
            $httpBackend.flush();
            expect(this.modal.container.find(".my-header").length).toEqual(1);
            $httpBackend.verifyNoOutstandingExpectation();
            return $httpBackend.verifyNoOutstandingRequest();
          }));
        });
        describe("with controller & resolves", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              controller: "TestCtrl",
              resolve: {
                data: (function(_this) {
                  return function() {
                    return _this.data;
                  };
                })(this)
              }
            });
          });
          it("exposes a promise that is resolved when the resolves are finished", function() {
            var modalResolved;
            modalResolved = null;
            this.modal.resolved.then(function(result) {
              return modalResolved = result;
            });
            expect(modalResolved).toBe(null);
            this.$rootScope.$digest();
            return expect(modalResolved).toEqual(this.modal);
          });
          return it("injects the modal scope and resolves into the controller", function() {
            this.$rootScope.$digest();
            expect(this.modal.scope.ctrlData).toEqual(this.data);
            expect(this.modal.controller).toBeDefined();
            return expect(this.modal.element.find(".ctrl-data").text()).toEqual(this.data);
          });
        });
        describe("with controllerAs & resolves", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              controller: "TestCtrl as testCtrl",
              resolve: {
                data: (function(_this) {
                  return function() {
                    return _this.data;
                  };
                })(this)
              }
            });
          });
          return it("injects the modal scope and resolves into the controller", function() {
            this.$rootScope.$digest();
            expect(this.modal.controller).toBeDefined();
            expect(this.modal.controller.ctrlAsData).toEqual(this.data);
            return expect(this.modal.element.find(".ctrl-as-data").text()).toEqual(this.data);
          });
        });
        describe("with containerClass", function() {
          beforeEach(function() {
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              containerClass: "pg-special-container"
            });
          });
          return it("adds the class to the container element", function() {
            this.$rootScope.$digest();
            return expect(this.modal.container).toHaveClass("pg-special-container");
          });
        });
        describe("with modalClass", function() {
          beforeEach(function() {
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              modalClass: "pg-special-modal"
            });
          });
          return it("adds the class to the container element", function() {
            this.$rootScope.$digest();
            return expect(this.modal.element).toHaveClass("pg-special-modal");
          });
        });
        describe("with keyboard false", function() {
          beforeEach(function() {
            this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              keyboard: false
            });
            return this.$animate.flush();
          });
          return it("does not close modal when ESC is pressed", function() {
            var evt;
            evt = jQuery.Event("keydown");
            evt.which = 27;
            this.$document.trigger(evt);
            return expect(this.modal.closing).not.toBe(true);
          });
        });
        describe("with click false", function() {
          beforeEach(function() {
            this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              click: false
            });
            return this.$animate.flush();
          });
          return it("does not close modal when the container element is clicked", function() {
            this.modal.container.trigger("click");
            return expect(this.modal.closing).not.toBe(true);
          });
        });
        describe("with locals", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              controller: "TestCtrl as testCtrl",
              locals: {
                data: this.data
              }
            });
          });
          return it("injects the modal scope and locals into the controller", function() {
            this.$rootScope.$digest();
            expect(this.modal.controller).toBeDefined();
            expect(this.modal.controller.ctrlAsData).toEqual(this.data);
            return expect(this.modal.element.find(".ctrl-as-data").text()).toEqual(this.data);
          });
        });
        describe("with scope", function() {
          beforeEach(function() {
            this.myScope = this.$rootScope.$new();
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              scope: this.myScope,
              controller: function($scope) {
                return $scope.data = "hello";
              }
            });
          });
          it("injects the provided scope to the modal", function() {
            this.$rootScope.$digest();
            expect(this.myScope.data).toBeDefined();
            expect(this.myScope.data).toEqual("hello");
            return expect(this.modal.element.find(".scope-data").text()).toEqual("hello");
          });
          return it("doesn't destroy the scope on close", function() {
            spyOn(this.myScope, "$destroy");
            this.modal.close();
            this.$animate.flush();
            return expect(this.myScope.$destroy).not.toHaveBeenCalled();
          });
        });
        describe("with scope but no controller", function() {
          beforeEach(function() {
            this.myScope = this.$rootScope.$new();
            this.myScope.data = "hello";
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              scope: this.myScope
            });
          });
          return it("binds the provided scope to the template", function() {
            this.$rootScope.$digest();
            return expect(this.modal.element.find(".scope-data").text()).toEqual("hello");
          });
        });
        describe("when a resolve error occurs", function() {
          beforeEach(function() {
            this.data = "foo";
            return this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              controller: "TestCtrl",
              resolve: {
                data: (function(_this) {
                  return function() {
                    return _this.$q.reject("Oh no!");
                  };
                })(this)
              }
            });
          });
          return it("rejects all the modal promises with the error", function() {
            var closed, opened, resolved;
            resolved = opened = closed = null;
            this.modal.resolved["catch"](function(error) {
              return resolved = error;
            });
            this.modal.opened["catch"](function(error) {
              return opened = error;
            });
            this.modal.closed["catch"](function(error) {
              return closed = error;
            });
            this.$rootScope.$digest();
            expect(resolved).toEqual("Oh no!");
            expect(opened).toEqual("Oh no!");
            return expect(closed).toEqual("Oh no!");
          });
        });
        describe("when a modal is already active", function() {
          beforeEach(function() {
            var opened;
            this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html"
            });
            opened = false;
            this.modal.opened.then(function() {
              return opened = true;
            });
            this.$animate.flush();
            return expect(opened).toBe(true);
          });
          return it("closes the existing modal, then opens the next one", function() {
            var i, newModal, newModalOpened, oldModalClosed;
            oldModalClosed = false;
            this.modal.closed.then(function() {
              return oldModalClosed = true;
            });
            newModal = this.modalService.openModal({
              templateUrl: "modal_template.html"
            });
            newModalOpened = false;
            newModal.opened.then(function() {
              return newModalOpened = true;
            });
            expect(oldModalClosed).toBe(false);
            expect(newModalOpened).toBe(false);
            for (i = 1; i <= 2; i++) {
              this.$animate.flush();
            }
            expect(oldModalClosed).toBe(true);
            return expect(newModalOpened).toBe(true);
          });
        });
        describe("when a previous modal open failed", function() {
          beforeEach(function() {
            var error;
            this.modal = this.modalService.openModal({
              templateUrl: "modal_template.html",
              resolve: {
                data: (function(_this) {
                  return function() {
                    return _this.$q.reject("Oh no!");
                  };
                })(this)
              }
            });
            error = false;
            this.modal.opened["catch"](function() {
              return error = true;
            });
            this.$rootScope.$digest();
            return expect(error).toBe(true);
          });
          return it("cleans up the shared state, and the next open succeeds", function() {
            var newModal, newModalOpened;
            newModal = this.modalService.openModal({
              templateUrl: "modal_template.html"
            });
            newModalOpened = false;
            newModal.opened.then(function() {
              return newModalOpened = true;
            });
            expect(newModalOpened).toBe(false);
            this.$animate.flush();
            return expect(newModalOpened).toBe(true);
          });
        });
        return describe("when opening multiple modals in series", function() {
          return it("opens them in calling order, after closing the previous first", function() {
            var closedModal, i, modal1, modal2, modal3, openedModal;
            modal1 = this.modalService.openModal({
              templateUrl: "modal_template.html",
              id: "modal1"
            });
            modal2 = this.modalService.openModal({
              templateUrl: "modal_template.html",
              id: "modal2"
            });
            modal3 = this.modalService.openModal({
              templateUrl: "modal_template.html",
              id: "modal3"
            });
            openedModal = "none";
            closedModal = "none";
            modal1.opened.then(function() {
              expect(openedModal).toEqual("none");
              expect(closedModal).toEqual("none");
              return openedModal = "modal1";
            });
            modal1.closed.then(function() {
              expect(openedModal).toEqual("modal1");
              expect(closedModal).toEqual("none");
              return closedModal = "modal1";
            });
            modal2.opened.then(function() {
              expect(openedModal).toEqual("modal1");
              expect(closedModal).toEqual("modal1");
              return openedModal = "modal2";
            });
            modal2.closed.then(function() {
              expect(openedModal).toEqual("modal2");
              expect(closedModal).toEqual("modal1");
              return closedModal = "modal2";
            });
            modal3.opened.then(function() {
              expect(openedModal).toEqual("modal2");
              expect(closedModal).toEqual("modal2");
              return openedModal = "modal3";
            });
            modal3.closed.then(function() {
              expect(openedModal).toEqual("modal3");
              expect(closedModal).toEqual("modal2");
              return closedModal = "modal3";
            });
            for (i = 1; i <= 5; i++) {
              this.$animate.flush();
            }
            expect(openedModal).toEqual("modal3");
            return expect(closedModal).toEqual("modal2");
          });
        });
      });
      describe("closeCurrentModal", function() {
        beforeEach(function() {
          this.modal = this.modalService.openModal({
            templateUrl: "modal_template.html"
          });
          return this.$animate.flush();
        });
        it("removes the element from the body", function() {
          this.modalService.closeCurrentModal();
          this.$rootScope.$digest();
          return expect(this.modal.element).not.toBeInDOM();
        });
        it("removes the class from the body indicating that the modal is open", function() {
          expect(angular.element("body").hasClass("dimmable dimmed")).toBe(true);
          this.modalService.closeCurrentModal();
          this.$animate.flush();
          return expect(angular.element("body").hasClass("dimmmable")).toBe(false);
        });
        it("resolves the modal's closed promise", function() {
          this.modal.closed.then((function(_this) {
            return function(result) {
              _this.closed = true;
              return _this.closed_value = result;
            };
          })(this));
          this.modalService.closeCurrentModal("some value");
          this.$animate.flush();
          expect(this.closed).toBe(true);
          return expect(this.closed_value).toEqual("some value");
        });
        it("destroys the modal scope", function() {
          this.modalService.closeCurrentModal();
          this.$animate.flush();
          return expect(this.modal.scope.$$destroyed).toBe(true);
        });
        return it("calls $animate.leave once", function() {
          spyOn(this.$animate, "leave").and.callThrough();
          this.modalService.closeCurrentModal();
          this.modalService.closeCurrentModal();
          this.$rootScope.$digest();
          this.modalService.closeCurrentModal();
          this.$rootScope.$digest();
          return expect(this.$animate.leave.calls.count()).toBe(1);
        });
      });
      return describe("isModalOpen", function() {
        it("returns false if no modal is open", function() {
          return expect(this.modalService.isModalOpen()).toBe(false);
        });
        it("returns true if a modal is open", function() {
          this.modal = this.modalService.openModal({
            templateUrl: "modal_template.html"
          });
          this.$animate.flush();
          return expect(this.modalService.isModalOpen()).toBe(true);
        });
        return it("returns false after the current modal is closed", function() {
          this.modal = this.modalService.openModal({
            templateUrl: "modal_template.html"
          });
          this.$animate.flush();
          expect(this.modalService.isModalOpen()).toBe(true);
          this.modalService.closeCurrentModal();
          this.$animate.flush();
          return expect(this.modalService.isModalOpen()).toBe(false);
        });
      });
    });
  });

}).call(this);
